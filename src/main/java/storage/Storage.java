package storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Scanner;

import exception.DukeException;
import parser.DateTimeParser;
import task.Deadline;
import task.Event;
import task.Task;
import task.TaskList;
import task.Todo;

/**
 * <h1>Storage class</h1>
 * Stores and reads tasks generated by the user to ensure the
 * tasks can be used the next time the chat bot is run.
 */
public class Storage {
    private static final String DEADLINE_REGEX = " \\(by: ";
    private static final String EVENT_REGEX = " \\(at: ";
    private static final String OUTPUT_FOLDER_NAME = "data";
    private static final String OUTPUT_FILE_NAME = "duke.txt";
    private static final String EMPTY_STRING = "";
    private final String folderPath;
    private final String filename;
    private final String userDirectory = System.getProperty("user.dir");

    /**
     * Creates a Storage object.
     *
     * @param folderPath folder path the output is to be saved at.
     * @param filename file name the output is to be saved as.
     */
    public Storage(String folderPath, String filename) {
        this.folderPath = folderPath;
        this.filename = filename;
    }

    /**
     * Returns an ArrayList of Tasks containing the saved Tasks, if they exist.
     *
     * @return ArrayList of Tasks
     * @throws DukeException if an error is encountered when the file
     *         is unable to be read.
     */
    public ArrayList<Task> readSavedTasks() throws DukeException {
        Path dataDirectoryPath = Paths.get(userDirectory, folderPath);
        Path savedTasksPath = Paths.get(userDirectory, folderPath, filename);
        if (!hasDataDirectory(dataDirectoryPath)) {
            createDataDirectory(dataDirectoryPath);
            return new ArrayList<>();
        }
        if (!hasSavedTasks(savedTasksPath)) {
            return new ArrayList<>();
        }
        File tasksFile = getTasksFile(savedTasksPath);
        try {
            return parseFileToTasks(tasksFile);
        } catch (FileNotFoundException e) {
            throw new DukeException(e.getMessage());
        }
    }

    /**
     * Writes the saved tasks to the output file.
     *
     * @param tasks TaskList to be written from.
     * @throws DukeException if an exception is encountered.
     */
    public void writeToFile(TaskList tasks) throws DukeException {
        try {
            FileWriter fw = new FileWriter(getRelativePath());
            fw.write(generateTasksToAdd(tasks));
            fw.close();
        } catch (IOException e) {
            throw new DukeException(e.getMessage());
        }
    }

    private File getTasksFile(Path savedTasksPath) {
        return new File(getAbsolutePath(savedTasksPath));
    }

    private ArrayList<Task> parseFileToTasks(File tasksFile) throws FileNotFoundException, DukeException {
        Scanner sc = new Scanner(tasksFile);
        ArrayList<Task> tasks = new ArrayList<>();
        while (sc.hasNext()) {
            String taskDescription = sc.nextLine();
            tasks.add(parseLineToTask(taskDescription));
        }
        return tasks;
    }

    private Task parseLineToTask(String line) throws DukeException {
        if (line.length() <= 7) {
            throw new DukeException(EMPTY_STRING);
        }
        char taskSymbol = line.charAt(1);
        boolean isDone = line.charAt(4) == 'X';
        switch (taskSymbol) {
        case 'T':
            return getTodoFromLine(line, isDone);
        case 'D':
            return getTaskFromLine(line, isDone, DEADLINE_REGEX);
        case 'E':
            return getTaskFromLine(line, isDone, EVENT_REGEX);
        default:
            throw new DukeException(EMPTY_STRING);
        }
    }

    private String trimInputDateString(String str) {
        return str.substring(0, str.length() - 1);
    }

    private Task getTaskFromLine(String line, boolean isDone, String regex) throws DukeException {
        switch (regex) {
        case EVENT_REGEX:
            String[] splittedEvent = line.substring(7).split(regex, 3);
            LocalDateTime eventDateTime = getLocalDateTimeFromString(splittedEvent);
            return new Event(splittedEvent[0], isDone, eventDateTime);
        case DEADLINE_REGEX:
            String[] splittedDeadline = line.substring(7).split(regex, 3);
            LocalDateTime deadlineDateTime = getLocalDateTimeFromString(splittedDeadline);
            return new Deadline(splittedDeadline[0], isDone, deadlineDateTime);
        default:
            throw new DukeException(EMPTY_STRING);
        }
    }

    private LocalDateTime getLocalDateTimeFromString(String[] splitTask) {
        String trimmedTaskDate = trimInputDateString(splitTask[1]);
        return DateTimeParser.changeStringToReadingDateTime(trimmedTaskDate);
    }
    private Todo getTodoFromLine(String line, boolean isDone) {
        return new Todo(line.substring(7), isDone);
    }

    private String getAbsolutePath(Path path) {
        return path.toAbsolutePath().toString();
    }

    private void createDataDirectory(Path dataDirectoryPath) throws DukeException {
        try {
            Files.createDirectories(dataDirectoryPath);
        } catch (IOException e) {
            throw new DukeException(e.getMessage());
        }
    }

    private boolean hasDataDirectory(Path dataDirectoryPath) {
        return Files.exists(dataDirectoryPath);
    }

    private boolean hasSavedTasks(Path savedTasksPath) {
        return Files.exists(savedTasksPath);
    }

    private String generateTasksToAdd(TaskList tasks) {
        StringBuilder stringBuilder = new StringBuilder();
        int tasksSize = tasks.getSize();
        for (int i = 0; i < tasksSize; i++) {
            stringBuilder.append(tasks.taskStringAtIndex(i) + System.lineSeparator());
        }
        return stringBuilder.toString();
    }

    private String getRelativePath() {
        Path path = Paths.get(userDirectory, OUTPUT_FOLDER_NAME, OUTPUT_FILE_NAME);
        return path.toAbsolutePath().toString();
    }
}
